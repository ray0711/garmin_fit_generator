#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');
const generatedDir = path.join(projectRoot, 'src', 'types_generated');
const outDir = path.join(projectRoot, 'src', 'types_auto');

// Ensure output dir exists
fs.mkdirSync(outDir, { recursive: true });

// Dynamic import of generated profile
const profilePath = path.join(generatedDir, 'profile.js');
const { default: Profile } = await import(pathToFileUrl(profilePath));

function pathToFileUrl(p) {
  const url = new URL('file:');
  const pathname = path.resolve(p).replace(/\\/g, '/');
  url.pathname = pathname.startsWith('/') ? pathname : '/' + pathname;
  return url.href;
}

// Utilities
const toScreamingSnake = (s) => s
  .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
  .replace(/\W+/g, '_')
  .replace(/__+/g, '_')
  .replace(/^_+|_+$/g, '')
  .toUpperCase();

const header = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-fit-types.mjs from src/types_generated/profile.js
// Source version: ${Profile.version?.profile || 'unknown'}
`;

function generateEnumsTs() {
  // Select enum sources from Profile.types
  const enumKeys = [
    'mesgNum',
    'file',
    'manufacturer',
    'sport',
    'subSport',
    'wktStepDuration',
    'wktStepTarget',
    'exerciseCategory',
    'intensity',
  ];
  let out = header + '\n';
  for (const key of enumKeys) {
    const src = Profile.types[key];
    if (!src) continue;
    const enumName =
      key === 'mesgNum' ? 'MesgNum' :
      key === 'file' ? 'FileType' :
      key === 'manufacturer' ? 'Manufacturer' :
      key === 'sport' ? 'Sport' :
      key === 'subSport' ? 'SubSport' :
      key === 'wktStepDuration' ? 'WktStepDuration' :
      key === 'wktStepTarget' ? 'WktStepTarget' :
      key === 'exerciseCategory' ? 'ExerciseCategory' :
      key === 'intensity' ? 'intensity' :
      toScreamingSnake(key);

    out += `export enum ${enumName} {\n`;
    for (const [numStr, name] of Object.entries(src)) {
      const num = Number(numStr);
      // Name from profile is camelCase; for MesgNum we want SCREAMING_SNAKE
      let ident = key === 'mesgNum' ? toScreamingSnake(name) : name;
      // Sanitize: replace invalid chars and prefix if starts with digit
      ident = /[^a-zA-Z0-9_$]/.test(ident) ? toScreamingSnake(ident) : ident;
      if (/^[0-9]/.test(ident)) ident = '_' + ident;
      out += `  ${ident} = ${num},\n`;
    }
    out += `}\n\n`;
  }
  return out;
}

function tsTypeForField(f) {
  // Rough mapping using profile metadata
  // f.baseType can be number of bits; f.type may refer to another enum in Profile.types
  const typeName = f.type;
  if (typeName && Profile.types[typeName]) {
    // Map to our exported enum names
    const map = {
      mesgNum: 'MesgNum',
      file: 'FileType',
      manufacturer: 'Manufacturer',
      sport: 'Sport',
      subSport: 'SubSport',
      wktStepDuration: 'WktStepDuration',
      wktStepTarget: 'WktStepTarget',
      exerciseCategory: 'ExerciseCategory',
      intensity: 'string', // SDK treats as string, our app stores custom intensity enum only in UI
    };
    const mapped = map[typeName];
    if (mapped) return mapped;
  }
  switch (f.baseType) {
    case 'byte':
    case 'enum':
    case 'uint8':
    case 'sint8':
    case 'uint16':
    case 'sint16':
    case 'uint32':
    case 'sint32':
    case 'uint64':
    case 'sint64':
    case 'float32':
    case 'float64':
      return 'number';
    case 'string':
      return 'string';
    default:
      // DateTime etc.
      if (typeName === 'dateTime') return 'Date';
      return 'number';
  }
}

function generateMessageInterface(name, definition) {
  const ifaceName = `Message_${name}`;
  let out = `export interface ${ifaceName} {\n`;
  out += `  mesgNum: MesgNum.${name};\n`;
  // Fields
  const fields = definition.fields || [];
  for (const f of fields) {
    // Skip developer fields
    if (f.name === 'unknown' || f.developer) continue;
    const tsName = f.name === 'messageIndex' ? 'messageIndex' : f.name;
    const tsType = tsTypeForField(f) + (f.array ? '[]' : '');
    const optional = f.required ? '' : '?';
    out += `  ${tsName}${optional}: ${tsType};\n`;
  }
  out += `}\n\n`;
  return out;
}

function generateMessagesTs() {
  const msgs = Profile.messages;
  // Map of interface names -> message keys in profile
  const pairs = [
    ['FILE_ID', 'fileId'],
    ['FILE_CREATOR', 'fileCreator'],
    ['WORKOUT', 'workout'],
    ['WORKOUT_STEP', 'workoutStep'],
    ['EXERCISE_TITLE', 'exerciseTitle'],
  ];
  let out = header + `import { MesgNum, Sport, SubSport, FileType, Manufacturer, WktStepDuration, WktStepTarget, ExerciseCategory } from './fitsdk_enums';\n\n`;

  for (const [ifaceName, profileKey] of pairs) {
    const def = msgs[profileKey];
    if (def) {
      out += generateMessageInterface(ifaceName, def);
    } else {
      // Fallback minimal typings if profile entry is missing
      if (ifaceName === 'FILE_ID') {
        out += `export interface Message_FILE_ID {\n  mesgNum: MesgNum.FILE_ID;\n  manufacturer?: Manufacturer;\n  product?: number;\n  serialNumber?: number;\n  timeCreated?: Date;\n  type?: FileType;\n}\n\n`;
      } else if (ifaceName === 'FILE_CREATOR') {
        out += `export interface Message_FILE_CREATOR {\n  mesgNum: MesgNum.FILE_CREATOR;\n  softwareVersion?: number;\n  hardwareVersion?: number;\n}\n\n`;
      } else if (ifaceName === 'WORKOUT') {
        out += `export interface Message_WORKOUT {\n  mesgNum: MesgNum.WORKOUT;\n  sport?: Sport;\n  subSport?: SubSport;\n  capabilities?: number;\n  numValidSteps?: number;\n  wktName?: string;\n  poolLength?: number;\n  poolLengthUnit?: string;\n  wktDescription?: string;\n}\n\n`;
      } else if (ifaceName === 'WORKOUT_STEP') {
        out += `export interface Message_WORKOUT_STEP {\n  mesgNum: MesgNum.WORKOUT_STEP;\n  messageIndex: number;\n  wktStepName?: string;\n  durationType?: WktStepDuration;\n  durationValue?: number;\n  targetType?: WktStepTarget;\n  targetValue?: number;\n  customTargetValueLow?: number;\n  customTargetValueHigh?: number;\n  intensity?: number;\n  notes?: string;\n  equipment?: string;\n  exerciseCategory?: ExerciseCategory;\n  exerciseName?: number;\n  exerciseWeight?: number;\n  weightDisplayUnit?: string;\n  secondaryTargetType?: string;\n  secondaryTargetValue?: number;\n  secondaryCustomTargetValueLow?: number;\n  secondaryCustomTargetValueHigh?: number;\n}\n\n`;
      } else if (ifaceName === 'EXERCISE_TITLE') {
        out += `export interface Message_EXERCISE_TITLE {\n  mesgNum: MesgNum.EXERCISE_TITLE;\n  messageIndex: number;\n  exerciseCategory?: ExerciseCategory;\n  exerciseName?: number;\n  wktStepName?: string;\n  exerciseTitle?: string;\n}\n\n`;
      }
    }
  }

  // Union of messages we write
  out += `export type FitMessage = ` + pairs.map(([n]) => `Message_${n}`).join(' | ') + `;\n`;
  return out;
}

const enumsTs = generateEnumsTs();
fs.writeFileSync(path.join(outDir, 'fitsdk_enums.ts'), enumsTs);

const messagesTs = generateMessagesTs();
fs.writeFileSync(path.join(outDir, 'MessageTypes.ts'), messagesTs);

console.log('Generated types into', outDir);
